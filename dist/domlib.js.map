{"mappings":"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","sources":["src/domlib.js"],"sourcesContent":["export default (d => {\r\n  d.isArr = Array.isArray\r\n\r\n  d.isNil = o => o == null\r\n\r\n  d.isDef = o => o != null\r\n\r\n  d.isFunc = o => o instanceof Function\r\n\r\n  d.isBool = o => typeof o === 'boolean'\r\n\r\n  d.isObj = o => o != null && o.constructor === Object\r\n\r\n  d.isStr = o => typeof o === 'string'\r\n\r\n  d.isNum = o => typeof o === 'number' && !isNaN(o)\r\n\r\n  d.isInt = o => d.isNum(o) && o % 1 === 0\r\n\r\n  d.isArrlike = o => o != null && (d.isArr(o) || (!(o instanceof Function || o instanceof Node) && o.length % 1 === 0))\r\n\r\n  d.isNode = o => o instanceof Node\r\n\r\n  d.isNodeList = (o, arr = true) => o instanceof NodeList || (arr && d.allare(o, d.isNode))\r\n\r\n  d.isPrimitive = o => (o = typeof o, o === 'string' || o === 'number' || o === 'boolean')\r\n\r\n  d.isEl = o => o instanceof Element\r\n\r\n  d.isPromise = o => typeof o === 'object' && d.isFunc(o.then)\r\n\r\n  d.isRegExp = o => o instanceof RegExp\r\n\r\n  d.isEmpty = o => d.isNil(o) || !((d.isObj(o) ? Object.keys(o) : o).length || o.size)\r\n\r\n  d.isMounted = (child, parent = document) => d.isNodeList(child) ? Array.from(child).every(n => d.isMounted(n)) : parent === child || !!(parent.compareDocumentPosition(child) & 16)\r\n\r\n  d.isSvg = o => o instanceof SVGElement\r\n\r\n  d.isInput = (o, contentEditable) => o instanceof HTMLInputElement || o instanceof HTMLTextAreaElement || (\r\n    !!contentEditable && o instanceof Element && o.getAttribute('contenteditable') === 'true'\r\n  )\r\n\r\n  d.isRenderable = o => o instanceof Node || d.isPrimitive(o) || d.allare(o, d.isRenderable)\r\n\r\n  /*\r\n   * allare checks whether all items in an array are like a given param\r\n   * it's similar to array.includes but allows functions\r\n   */\r\n  d.allare = (arr, like) => {\r\n    if (!d.isArrlike(arr)) return false\r\n    const isfn = like instanceof Function\r\n    for (let i = 0; i < arr.length; i++) {\r\n      if (!(isfn ? like(arr[i]) : arr[i] === like)) {\r\n        return false\r\n      }\r\n    }\r\n    return true\r\n  }\r\n\r\n  /*\r\n   * compose a typical function composition functions\r\n   * @ example compose(x => x + 1, x => x + 1)(1) === 3\r\n   */\r\n  d.compose = (...fns) => fns.reduce((a, b) => (...args) => a(b(...args)))\r\n\r\n  /*\r\n   * curry a function\r\n   * and optionally\r\n   * set the arity or pre bound arguments\r\n   */\r\n  d.curry = (fn, arity = fn.length, ...args) => arity <= args.length ? fn(...args) : d.curry.bind(null, fn, arity, ...args)\r\n\r\n  d.assign = Object.assign\r\n\r\n  d.clone = (host, empty) => d.assign(empty ? Object.create(null) : {}, host)\r\n\r\n  /*\r\n   * flatten recursively spreads out nested arrays\r\n   * to make the entire array one dimentional\r\n   * @example flatten([1, [2, [3]], 4, [5]]) -> [1, 2, 3, 4, 5]\r\n   * @example flatten(x) -> [x]\r\n   */\r\n  d.flatten = (arr, result = [], encaptulate = true) => {\r\n    if (encaptulate && !d.isArr(arr)) return [arr]\r\n    for (let i = 0; i < arr.length; i++)\r\n      d.isArr(arr[i]) ? d.flatten(arr[i], result) : d.result.push(arr[i])\r\n    return result\r\n  }\r\n\r\n  /*\r\n   * runAsync runs a function asynchronously\r\n   */\r\n  d.runAsync = window.requestIdleCallback ? (fn, ...args) => window.requestIdleCallback(fn.bind(undefined, ...args)) : (fn, ...args) => setTimeout(fn, 0, ...args)\r\n\r\n  /*\r\n   * run runs a function on DOMContentLoaded or asynchronously\r\n   * if document.body is present and loaded\r\n   */\r\n  d.run = function () {\r\n    document.body || document.readyState === 'complete' ?\r\n      d.runAsync.apply(undefined, arguments) :\r\n      window.addEventListener('DOMContentLoaded', e => {\r\n        d.runAsync.apply(undefined, arguments)\r\n      }, {once: true})\r\n  }\r\n\r\n  d.html = (input, ...args) => {\r\n    if (args.length > 2) return d.h(input, ...args)\r\n    if (input instanceof Function) input = input(...args)\r\n    if (input instanceof Promise) return new Promise(resolve => {\r\n      input.then(i => resolve(d.html(i, ...args)))\r\n    })\r\n    if (input instanceof Node) return input\r\n    if (d.isNum(input)) input = String(input)\r\n    if (typeof input === 'string') return Array.from(document.createRange().createContextualFragment(input).childNodes)\r\n    if (d.isArr(input)) return input.map(i => d.html(i, ...args))\r\n    throw new Error('.html: unrenderable input')\r\n  }\r\n\r\n  d.frag = inner => inner != null ? d.html(inner) : document.createDocumentFragment()\r\n\r\n  /*\r\n   * DOM Query Selector Functions\r\n   */\r\n  d.query = (selector, host = document) => d.isNode(selector) ? selector : d.query(host).querySelector(selector)\r\n\r\n  d.queryAsync = (selector, host) => new Promise((resolve, reject) => {\r\n    const find = () => {\r\n      const result = d.query(selector, host)\r\n      result == null ?\r\n        reject(new Error(\"queryAsync: couldn't find \" + selector)) :\r\n        resolve(result)\r\n    }\r\n    document.body ? find() : d.run(find)\r\n  })\r\n\r\n  /*\r\n   *  queryAll(selector String|Node, host = document String|Node)\r\n   *  it returns an array of elements matching a selector,\r\n   *  a nicer querySelectorAll essentially.\r\n   */\r\n  d.queryAll = (selector, host = document) => Array.from(d.query(host).querySelectorAll(selector))\r\n\r\n  d.queryEach = (selector, fn, host = document) => {\r\n    if (!d.isFunc(fn))[fn, host] = [host, document]\r\n    return d.each(d.queryAll(selector, host), fn)\r\n  }\r\n\r\n  /*\r\n   * each iterates over arrays, objects, integers,\r\n   * and anything implementing .forEach\r\n   */\r\n  d.each = (iterable, fn) => {\r\n    if (iterable != null) {\r\n      if (d.isObj(iterable)) {\r\n        for (const key in iterable) fn(iterable[key], key, iterable)\r\n      } else if (iterable.length) {\r\n        const len = iterable.length\r\n        let i = 0\r\n        while (i !== len) fn(iterable[i], i++, iterable)\r\n      } else if (iterable.forEach) {\r\n        iterable.forEach(fn)\r\n      } else if (d.isInt(iterable)) {\r\n        let i = 0\r\n        while (i < iterable) fn(i++, iterable)\r\n      }\r\n    }\r\n    return iterable\r\n  }\r\n\r\n  /*\r\n   * infinify takes a function that has a string (like an event type or key)\r\n   * and returns a proxy which binds the key of any get operation\r\n   * as that initial string argument enabling a very natural feeling API\r\n   * @scope infinify(func) -> Proxy<func>\r\n   * @example const emit = infinify(emitFN); emit.anyEvent(details)\r\n   */\r\n  d.infinify = (fn, reflect) => new Proxy(fn, {\r\n    get: reflect === true ?\r\n      (fn, key) => key in fn ? Reflect.get(fn, key) : fn.bind(null, key) : (fn, key) => fn.bind(null, key)\r\n  })\r\n\r\n  d.copyprop = (host, obj, key) => (Object.defineProperty(host, key, Object.getOwnPropertyDescriptor(obj, key)), host)\r\n\r\n  /*\r\n   * merge(host Object|Array, target Object|Array)\r\n   * merge objects together deeply.\r\n   * it copies prop descriptions instead of raw values.\r\n   */\r\n  d.merge = (host, target) => {\r\n    if (d.isArr(host) && d.isArr(target)) {\r\n      for (const val of target)\r\n        if (!host.includes(val)) host.push(val)\r\n    } else if (d.merge.able(host) && d.merge.able(target)) {\r\n      for (const key in target) {\r\n        if (key in host) {\r\n          const old = host[key]\r\n          const val = target[key]\r\n          if (d.merge.able(old) && d.merge.able(val)) {\r\n            d.merge(old, val)\r\n          } else if (val != null) {\r\n            d.copyprop(host, target, key)\r\n          }\r\n        } else {\r\n          d.copyprop(host, target, key)\r\n        }\r\n      }\r\n    }\r\n    return host\r\n  }\r\n\r\n  d.merge.able = o => d.isArr(o) || (o != null && typeof o === 'object' && !d.isFunc(o.then))\r\n\r\n  d.emitter = (host = Object.create(null), listeners = new Map()) => Object.assign(host, {\r\n    emit: d.infinify((event, ...data) => d.runAsync(() => {\r\n      if (listeners.has(event))\r\n        for (const h of listeners.get(event)) h.apply(null, data)\r\n    })),\r\n    on: d.infinify((event, handler) => {\r\n      if (!listeners.has(event)) listeners.set(event, new Set())\r\n      listeners.get(event).add(handler)\r\n      const manager = () => host.off(event, handler)\r\n      manager.off = manager\r\n      manager.on = () => (manager(), host.on(event, handler))\r\n      manager.once = () => (manager(), host.once(event, handler))\r\n      return manager\r\n    }),\r\n    once: d.infinify((event, handler) => host.on(event, function h() {\r\n      handler(...arguments)\r\n      host.off(event, h)\r\n    })),\r\n    off: d.infinify((event, handler) => {\r\n      if (listeners.has(event)) {\r\n        const ls = listeners.get(event)\r\n        ls.delete(handler)\r\n        if (!ls.size || handler == null) listeners.delete(event)\r\n      }\r\n    }),\r\n    clear: () => (listeners.clear(), host)\r\n  })\r\n\r\n  const listen = function (once, target, type, fn, options = false) {\r\n    if (d.isStr(target)) target = d.queryAll(target)\r\n    if ((d.isArr(target) || target instanceof NodeList) && target.length === 1) {\r\n      target = target[0]\r\n    }\r\n    if (!target || (d.isArr(target) && !target.length) || !target.addEventListener) {\r\n      throw new Error('nil/empty event target(s)')\r\n    }\r\n\r\n    let typeobj = d.isObj(type)\r\n    if (type == null || !(typeobj || d.isStr(type))) {\r\n      throw new TypeError('cannot listen to nil or invalid event type')\r\n    }\r\n\r\n    if (d.isArr(target)) {\r\n      for (let i = 0; i < target.length; i++) {\r\n        target[i] = listen(once, target[i], typeobj ? d.clone(type) : type, fn, options)\r\n      }\r\n      target.off = () => {\r\n        for (const h of target) h()\r\n        return target\r\n      }\r\n      target.on = mode => {\r\n        for (const h of target) h.on(mode)\r\n        return target\r\n      }\r\n      return target\r\n    }\r\n\r\n    if (typeobj) {\r\n      for (const name in type) {\r\n        type[name] = listen(once, target, name, type[name], options)\r\n      }\r\n      target.off = () => {\r\n        for (const h of Object.values(type)) h()\r\n        return target\r\n      }\r\n      target.on = mode => {\r\n        for (const h of Object.values(type)) h.on(mode)\r\n        return target\r\n      }\r\n      return type\r\n    }\r\n\r\n    let wrapper\r\n    if (typeof fn === 'string' && options instanceof Function) {\r\n      let matcher = fn\r\n      fn = options\r\n      options = arguments[5]\r\n      if (options == null) options = false\r\n      wrapper = function (event) {\r\n        if (\r\n          event.target != null &&\r\n          event.target !== this &&\r\n          event.target.matches(matcher)\r\n        ) {\r\n          fn.call(this, event, target)\r\n          if (off.once) off()\r\n        }\r\n      }\r\n    } else {\r\n      wrapper = function (event) {\r\n        fn.call(this, event, target)\r\n        if (off.once) off()\r\n      }\r\n    }\r\n\r\n    const on = mode => {\r\n      if (mode != null && mode !== off.once) off.once = !!mode\r\n      target.addEventListener(type, wrapper, options)\r\n      off.ison = true\r\n      return off\r\n    }\r\n\r\n    const off = d.assign(() => {\r\n      target.removeEventListener(type, wrapper)\r\n      off.ison = false\r\n      return off\r\n    }, {\r\n      target,\r\n      on,\r\n      once\r\n    })\r\n    off.off = off\r\n\r\n    return on()\r\n  }\r\n\r\n  const infinifyListen = {\r\n    get: (ln, type) => (tgt, fn, opts) => ln(tgt, type, fn, opts)\r\n  }\r\n\r\n  d.on = new Proxy(listen.bind(null, false), infinifyListen)\r\n  d.once = new Proxy(listen.bind(null, true), infinifyListen)\r\n  d.EventManager = d.curry(listen, 3)\r\n\r\n  // vpend - virtual append, add nodes and append them as a document fragment\r\n  d.vpend = (\r\n    children,\r\n    host,\r\n    connector = 'appendChild',\r\n    dfrag = d.frag(),\r\n    noHostAppend\r\n  ) => {\r\n    for (let i = 0; i < children.length; i++) {\r\n      let child = children[i]\r\n      if (child instanceof Function) {\r\n        if ((child = child(host)) === host) continue\r\n        else if (child instanceof Function) {\r\n          let lvl = 0\r\n          let ishost = false\r\n          let lastchild\r\n          while (child instanceof Function && lvl < 25) {\r\n            lastchild = child\r\n            child = child()\r\n            if ((ishost = child === host) || lastchild === child) break\r\n            lvl++\r\n          }\r\n          if (ishost) continue\r\n        }\r\n      }\r\n\r\n      if (child == null) continue\r\n      const ctr = child.constructor\r\n      if (ctr === String || ctr === Number) {\r\n        if (!child.length) continue\r\n        child = new Text(child)\r\n      } else if (d.isArr(child)) {\r\n        child = d.vpend(child, host, connector, dfrag, true)\r\n      }\r\n\r\n      if (child instanceof Node) {\r\n        dfrag.appendChild(child)\r\n        children[i] = child\r\n      }\r\n    }\r\n    if (host && !noHostAppend) d.run(() => host[connector](dfrag))\r\n    return children\r\n  }\r\n\r\n  /*\r\n   * prime takes an array of renderable entities\r\n   * and turns them into just nodes and functions\r\n   * (to be unwrapped/degloved later rather than sooner [by vpend])\r\n   */\r\n  d.prime = (...nodes) => {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      let n = nodes[i]\r\n      const ntype = typeof n\r\n      if (n == null || ntype === 'boolean') {\r\n        nodes.splice(i, 1)\r\n        continue\r\n      }\r\n      if (n instanceof Node || n instanceof Function) {\r\n        continue\r\n      } else if (ntype === 'string' || ntype === 'number') {\r\n        const nextI = i + 1\r\n        if (nextI < nodes.length) {\r\n          const next = nodes[nextI]\r\n          const nexttype = typeof next\r\n          if (nexttype === 'string' || nexttype === 'number') {\r\n            nodes[i] = String(n) + String(next)\r\n            nodes.splice(nextI, 1)\r\n            i--\r\n          }\r\n        } else {\r\n          nodes[i] = new Text(String(n))\r\n        }\r\n        continue\r\n      }\r\n\r\n      const isnl = n instanceof NodeList\r\n      if (isnl) {\r\n        if (n.length < 2) {\r\n          nodes[i] = n[0]\r\n          continue\r\n        }\r\n        n = Array.from(n)\r\n      } else if (n.constructor === Object) {\r\n        n = Object.values(n)\r\n      }\r\n\r\n      if (d.isArr(n)) {\r\n        if (!isnl) {\r\n          n = d.prime.apply(null, n)\r\n          if (n.length < 2) {\r\n            nodes[i] = n[0]\r\n            i--\r\n            continue\r\n          }\r\n        }\r\n        nodes.splice(i, 1, ...n)\r\n        i--\r\n      } else if (n != null) {\r\n        throw new Error(`illegal renderable: ${n}`)\r\n      }\r\n    }\r\n    return nodes\r\n  }\r\n\r\n  /*\r\n   * attach renderables to a host node via a connector\r\n   * like append, prepend, before, after\r\n   * independant of load state\r\n   */\r\n  d.attach = (host, connector, ...renderables) => {\r\n    if (host instanceof Function) host = host()\r\n    if (renderables.length === 1 && d.isArr(renderables[0])) renderables = renderables[0]\r\n    const nodeHost = host instanceof Node\r\n    renderables = d.prime(renderables)\r\n    if (nodeHost)\r\n      d.vpend(renderables, host, connector)\r\n    else if (typeof host === 'string')\r\n      return d.queryAsync(host).then(h => d.attach(h, connector, ...renderables))\r\n    if (d.isArr(host)) host.push(...renderables)\r\n    return renderables.length === 1 ? renderables[0] : renderables\r\n  }\r\n\r\n  /*\r\n   * render attaches one node to another\r\n   */\r\n  d.render = (node, host = document.body || 'body', connector = 'appendChild') => d.attach(host, connector, node)\r\n\r\n  const infinifyDOM = (gen, tag) => tag in gen ? Reflect.get(gen, tag) :\r\n    (gen[tag] = new Proxy(gen.bind(null, tag), {\r\n      get(fn, classes) {\r\n        classes = classes.replace(/_/g, '-').split('.')\r\n        return new Proxy(function () {\r\n          const el = fn.apply(null, arguments)\r\n          el.classList.add(...classes)\r\n          return el\r\n        }, {\r\n          get(_, anotherClass, proxy) {\r\n            classes.push(...anotherClass.replace(/_/g, '-').split('.'))\r\n            return proxy\r\n          }\r\n        })\r\n      }\r\n    }))\r\n\r\n  d.actualDF = {}\r\n  const domfn = new Proxy(d, {\r\n    get: (d, key) => d.actualDF[key] || infinifyDOM(d, key),\r\n    set: (d, key, val) => Reflect.set(d.actualDF, key, val)\r\n  })\r\n  \r\n\r\n  domfn.css = (node, styles, prop) => {\r\n    if (styles == null) {\r\n      if (document.defaultView) {\r\n        return document.defaultView.getComputedStyle(node)\r\n      }\r\n    } else if (styles.constructor === Object) {\r\n      for (const key in styles) domfn.css(node, key, styles[key])\r\n    } else if (typeof styles === 'string') {\r\n      if (prop == null) {\r\n        if (styles && styles[0] === '-') return node.getPropertyValue(styles)\r\n        if (document.defaultView) {\r\n          const style = document.defaultView.getComputedStyle(node)\r\n          if (style) return styles ? style[styles] : style\r\n        }\r\n      } else if (styles[0] === '-') {\r\n        node.style.setProperty(styles, prop)\r\n      } else {\r\n        node.style[styles] = prop\r\n      }\r\n    }\r\n    return node\r\n  }\r\n\r\n  domfn.class = (node, c, state) => {\r\n    if (node && c != null && node.classList) {\r\n      if (Array.isArray(node)) {\r\n        for (const n of node) domfn.class(n, c, state)\r\n      } else if (c.constructor === Object) {\r\n        for (const name in c) {\r\n          if (c[name] === true) node.classList.add(name)\r\n          else if (c[name] === false) node.classList.remove(name)\r\n          else for (const cl of c) node.classList.toggle(name)\r\n        }\r\n      } else {\r\n        if (typeof c === 'string') c = c.split(' ')\r\n        for (const cl of c) {\r\n          if (state === true) node.classList.add(cl)\r\n          else if (state === false) node.classList.remove(cl)\r\n          else node.classList.toggle(cl)\r\n        }\r\n      }\r\n    }\r\n    return node\r\n  }\r\n\r\n  domfn.hasClass = (node, name) => node.classList.contains(name)\r\n\r\n  domfn.attr = (node, attr, val) => {\r\n    if (attr.constructor === Object) {\r\n      for (const a in attr) {\r\n        const present = attr[a] == null\r\n        node[present ? 'removeAttribute' : 'setAttribute'](a, attr[a])\r\n      }\r\n    } else if (typeof attr === 'string') {\r\n      const old = node.getAttribute(attr)\r\n      if (val != null) {\r\n        node.setAttribute(attr, val)\r\n      }\r\n      return old\r\n    }\r\n    return node\r\n  }\r\n\r\n  domfn.removeAttribute = (node, ...attrs) => {\r\n    if (attrs.length === 1) node.removeAttribute(attrs[0])\r\n    else for (let i = 0; i < attrs.length; i++) {\r\n      if (d.isArr(attrs[i])) {\r\n        attrs.splice(i, 1, ...attrs[i])\r\n        i--\r\n      }\r\n      node.removeAttribute(attrs[i])\r\n    }\r\n    return node\r\n  }\r\n\r\n  domfn.attrToggle = (\r\n    node,\r\n    name,\r\n    state = !node.hasAttribute(name),\r\n    val = node.getAttribute(name) || ''\r\n  ) => {\r\n    if (state) {\r\n      node.setAttribute(name, val)\r\n    } else {\r\n      node.removeAttribute(name)\r\n    }\r\n    return node\r\n  }\r\n\r\n  domfn.emit = (node, type, detail) => (node.dispatchEvent(type instanceof String ? new CustomEvent(type, {detail}) : type), node)\r\n  domfn.append = (node, ...children) => (d.attach(node, 'appendChild', ...children), node)\r\n  domfn.prepend = (node, ...children) => (d.attach(node, 'prepend', ...children), node)\r\n  domfn.appendTo = (node, host) => (d.attach(node, 'appendChild', host), node)\r\n  domfn.prependTo = (node, host) => (d.attach(node, 'prepend', host), node),\r\n  domfn.clear = node => (node[d.isInput(node) ? 'value' : 'textContent'] = '', node)\r\n\r\n  domfn.refurbish = node => {\r\n    node.removeAttribute('class')\r\n    for (const {name} of node.attributes) node.removeAttribute(name)\r\n    return domfn.clear(node)\r\n  }\r\n\r\n  domfn.remove = (node, after) => {\r\n    if (node instanceof Function) node = node()\r\n    if (typeof node === 'string') node = document.querySelector(node)\r\n    if (d.isArr(node))\r\n      for (const n of node) domfn.remove(n, after)\r\n    else if (d.isNum(after)) {\r\n      return new Promise(res => setTimeout(() => res(domfn.remove(node)), after))\r\n    } else if (d.isMounted(node)) d.run(() => node.remove())\r\n    else if (d.isNodeList(node))\r\n      for (let i = 0; i < node.length; i++) domfn.remove(node[i])\r\n    return node\r\n  }\r\n\r\n  domfn.replace = (node, newnode) => {\r\n    if (newnode instanceof Function) newnode = newnode()\r\n    d.run(() => node.replaceWith(newnode))\r\n    return newnode\r\n  }\r\n\r\n  domfn.find = d.queryAll\r\n  domfn.findOne = d.query\r\n  \r\n  domfn.empty = domfn.clear\r\n  d.domfn = domfn\r\n\r\n  d.txt = str => new Text(str)\r\n\r\n  d.assimilate = Object.assign((el, {props, methods}) => {\r\n    if (props) d.assimilate.props(el, props)\r\n    if (methods) d.assimilate.methods(el, methods)\r\n  }, {\r\n    props(el, props) {\r\n      for (const prop in props) {\r\n        let val = props[prop]\r\n        if (prop in el) {\r\n          el[prop] = val\r\n        } else if (prop === 'accessors') {\r\n          for (const key in val) {\r\n            const {set = val[key], get = val[key]} = val[key]\r\n            const accessors = {}\r\n            if (set instanceof Function) {\r\n              accessors.set = set.bind(el, el)\r\n            }\r\n            if (get instanceof Function) {\r\n              accessors.get = get.bind(el, el)\r\n            }\r\n            Object.defineProperty(el, key, accessors)\r\n          }\r\n        } else if (val instanceof Function) {\r\n          el[prop] = val.call(el, el)\r\n        } else {\r\n          copyprop(el, props, prop)\r\n        }\r\n      }\r\n    },\r\n    methods(el, methods) {\r\n      for (const name in methods) Object.defineProperty(el, name, {\r\n        value: methods[name].bind(el, el)\r\n      })\r\n    }\r\n  })\r\n\r\n  d.h = (strs, ...args) => {\r\n    let result = ''\r\n    for (let i = 0; i < args.length; i++) result += strs[i] + args[i]\r\n    result += strs[strs.length - 1]\r\n\r\n    const template = document.createElement('template')\r\n    template.innerHTML = result\r\n    const {\r\n      content\r\n    } = template\r\n\r\n    content.collect = ({\r\n      attr = 'ref',\r\n      keep,\r\n      assign = {}\r\n    } = {}) => {\r\n      Array.from(content.querySelectorAll('[' + attr + ']')).reduce((a, el) => {\r\n        const ref = el.getAttribute(attr).trim()\r\n        if (!keep) el.removeAttribute(attr)\r\n        a[ref] = el\r\n        return a\r\n      }, assign)\r\n      return assign\r\n    }\r\n    content.renderCollect = (...args) => {\r\n      const collection = content.collect()\r\n      d.render(content, ...args)\r\n      return collection\r\n    }\r\n    return content\r\n  }\r\n\r\n  const mutateSet = set => (n, state) =>\r\n    set[state == null ? 'has' : state ? 'add' : 'delete'](n)\r\n\r\n  const Initiated = new Map()\r\n  const beenInitiated = (name, el) => Initiated.has(name) && Initiated.get(name)(el)\r\n\r\n  const attributeObserver = (el, name, opts) => {\r\n    let {init, update, remove} = opts\r\n    if (!init && !update && opts instanceof Function) [init, update] = [opts, opts]\r\n    const intialize = (present, value) => {\r\n      if (present && !beenInitiated(name, el)) {\r\n        if (init) init(el, value)\r\n        if (!Initiated.has(name)) {\r\n          Initiated.set(name, mutateSet(new WeakSet()))\r\n        }\r\n        Initiated.get(name)(el, true)\r\n        return true\r\n      }\r\n      return beenInitiated(name, el)\r\n    }\r\n    let removedBefore = false\r\n    let old = el.getAttribute(name)\r\n    intialize(el.hasAttribute(name), old)\r\n    const stop = d.on.attr(el, ({name: attrName, value, oldvalue, present}) => {\r\n      if (\r\n        attrName === name &&\r\n        old !== value &&\r\n        value !== oldvalue &&\r\n        intialize(present, value)\r\n      ) {\r\n        if (present) {\r\n          if (update) update(el, value, old)\r\n          removedBefore = false\r\n        } else if (!removedBefore) {\r\n          if (remove) remove(el, value, old)\r\n          removedBefore = true\r\n        }\r\n        old = value\r\n      }\r\n    })\r\n\r\n    const manager = () => {\r\n      stop()\r\n      if (Initiated.has(name)) Initiated.get(name)(el, false)\r\n    }\r\n    manager.start = () => {\r\n      stop.on()\r\n      Initiated.get(name)(el, true)\r\n    }\r\n    return (manager.stop = manager)\r\n  }\r\n\r\n  const directives = new Map()\r\n  d.directive = (name, opts) => {\r\n    const directive = new Map()\r\n    directive.init = el => {\r\n      if (!beenInitiated(name, el))\r\n        directive.set(el, attributeObserver(el, name, opts))\r\n    }\r\n    directive.stop = el => {\r\n      if (directive.has(el)) directive.get(el)()\r\n    }\r\n    directives.set(name, directive)\r\n    d.run(() => d.queryEach('[' + name + ']', n => attributeChange(n, name)))\r\n    return directive\r\n  }\r\n\r\n  const attributeChange = (\r\n    el,\r\n    name,\r\n    oldvalue,\r\n    value = el.getAttribute(name),\r\n    present = el.hasAttribute(name)\r\n  ) => {\r\n    if (directives.has(name)) directives.get(name).init(el)\r\n    if (value !== oldvalue) {\r\n      el.dispatchEvent(d.assign(new CustomEvent('attr'), {\r\n        name,\r\n        value,\r\n        oldvalue,\r\n        present\r\n      }))\r\n    }\r\n  }\r\n\r\n  d.createElementPlugins = {}\r\n\r\n  return d\r\n})(\r\n  function d(tag, ops, ...children) {\r\n    const el = tag.constructor === String ? document.createElement(tag) : tag\r\n    const opsisObj = d.isObj(ops)\r\n    if (opsisObj) {\r\n      d.assimilate(el, ops)\r\n      let val\r\n      for (const key in ops) {\r\n        if ((val = ops[key]) == null) continue\r\n\r\n        if (key[0] == 'o' && key[1] == 'n') {\r\n          const isOnce = key[2] == 'c' && key[3] == 'e'\r\n          const i = isOnce ? 4 : 2\r\n          const mode = key.substr(0, i)\r\n          let type = key.substr(i)\r\n          const evtfn = d.EventManager(isOnce)\r\n          if (!ops[mode]) ops[mode] = {}\r\n          if (d.isFunc(val)) {\r\n            ops[mode][type] = evtfn(el, val.name.substr(i), val)\r\n            delete ops[val.name]\r\n          } else {\r\n            const args = d.isArr(val) ? val : [val]\r\n            ops[mode][type] = type.length ? evtfn(el, type, ...args) : evtfn(el, ...args)\r\n          }\r\n        } else if (key in el) {\r\n          if (el[key] instanceof Function) {\r\n            d.isArr(val) ? el[key].apply(el, val) : el[key](val)\r\n          } else {\r\n            el[key] = ops[key]\r\n          }\r\n        } else if (key in d.actualDF) {\r\n          val = d.isArr(val) ? d.actualDF[key](el, ...val) : d.actualDF[key](el, val)\r\n          if (val !== el) ops[key] = val\r\n        } else if (key in d.createElementPlugins) {\r\n          d.createElementPlugins[key](val, el, ops)\r\n        }\r\n      }\r\n\r\n      const host = ops.$ || ops.render || ops.$pre\r\n      if (host) {\r\n        d.attach(host, host == ops.$pre ? 'prepend' : 'appendChild', el)\r\n      }\r\n    }\r\n\r\n    if (el.nodeType !== 3) {\r\n      if (!opsisObj) {\r\n        if (ops instanceof Function) {\r\n          const result = ops.call(el, el)\r\n          ops = result !== el ? result : undefined\r\n        }\r\n        if (d.isRenderable(ops)) children.unshift(ops)\r\n      }\r\n      if (children.length) d.attach(el, 'appendChild', children)\r\n    }\r\n    return el\r\n  }\r\n)"],"names":["d","isArr","Array","isArray","isNil","o","isDef","isFunc","Function","isBool","isObj","constructor","Object","isStr","isNum","isNaN","isInt","isArrlike","Node","length","isNode","isNodeList","arr","NodeList","allare","isPrimitive","isEl","Element","isPromise","then","isRegExp","RegExp","isEmpty","keys","size","isMounted","child","parent","document","from","every","n","compareDocumentPosition","isSvg","SVGElement","isInput","contentEditable","HTMLInputElement","HTMLTextAreaElement","getAttribute","isRenderable","like","isfn","i","fns","reduce","a","b","args","curry","fn","arity","bind","assign","host","empty","create","flatten","result","encaptulate","push","runAsync","window","requestIdleCallback","undefined","setTimeout","run","body","readyState","apply","arguments","addEventListener","e","input","h","Promise","resolve","html","String","createRange","createContextualFragment","childNodes","map","Error","inner","createDocumentFragment","selector","query","querySelector","reject","find","queryAll","querySelectorAll","queryEach","each","iterable","key","len","forEach","i1","reflect","Proxy","Reflect","get","obj","defineProperty","getOwnPropertyDescriptor","merge","target","val","includes","able","old","val1","copyprop","listeners","Map","infinify","event","data","has","on","handler","set","Set","add","manager","off","once","ls","delete","clear","type","options","wrapper","typeobj","TypeError","listen","clone","mode","name","values","matcher","this","matches","call","ison","removeEventListener","infinifyListen","ln","tgt","opts","children","connector","dfrag","frag","noHostAppend","lastchild","lvl","ishost","ctr","Number","Text","vpend","appendChild","prime","nodes","ntype","splice","nextI","next","nexttype","isnl","attach","renderables","queryAsync","node","domfn","actualDF","tag","gen","classes","replace","split","el","classList","_","anotherClass","proxy","css","styles","prop","defaultView","getComputedStyle","getPropertyValue","style","setProperty","c","state","class","remove","cl","toggle","cl1","hasClass","contains","attr","setAttribute","removeAttribute","attrs","hasAttribute","emit","detail","dispatchEvent","CustomEvent","appendTo","prependTo","refurbish","attributes","after","res","newnode","replaceWith","findOne","txt","str","assimilate","props","methods","accessors","value","strs","createElement","innerHTML","content","template","collect","keep","ref","trim","renderCollect","collection","render","beenInitiated","Initiated","init","directive","update","intialize","present","WeakSet","removedBefore","stop","attrName","oldvalue","attributeObserver","directives","attributeChange"],"version":3,"file":"domlib.js.map"}